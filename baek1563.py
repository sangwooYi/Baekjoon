"""
개근상 받을수 없는 조건
1. 지각 두번 이상 (즉 지각은 한번밖에 안됨) 이걸 DP로 어케체크하냐 ㅡㅡ?
2. 결석 세번 이상

DP[i][j][k]
i 는 인덱스
j 는 지각 유무 (0 , 1)
k 는 결석 연속 횟수

"""
N = 4
# N = int(input())

mod = 1000000
DP = [[[0] * 3 for _ in range(0, 2)] for _ in range(0, N)]
# 초깃값 설정
DP[0][0][0] = 1 # 출석
DP[0][1][0] = 1 # 지각
DP[0][0][1] = 1 # 결석

# + 나머지 정리 익숙해지자.
for i in range(1, N):
    # 현재 결석0이될 경우 (i-1에서 지각0회인 경우의 모든 경우가 다됨 (결석은 몇회이던 연속만 따짐))
    DP[i][0][0] = (DP[i-1][0][0] + DP[i-1][0][1] + DP[i-1][0][2]) % mod
    # 현재는 출석이므로  이전에 지각한 모든 경우도 포함 (지각도 늦은것뿐 출석처리는 되는것)
    # 즉 현재 출석이 그냥 출석한거냐 (DP[i][1] 에서 옴), 지각해서 출석한거냐 (DP[i][0]에서 옴)
    DP[i][1][0] = (DP[i-1][0][0] + DP[i-1][0][1] + DP[i-1][0][2]) % mod + (DP[i-1][1][0] + DP[i-1][1][1] + DP[i-1][1][2]) % mod
    # 결석 1회가 될 경우 i-1번째에서 결석0회였던 경우에서 현재 결석 한것
    DP[i][0][1] = DP[i-1][0][0] % mod
    DP[i][1][1] = DP[i-1][1][0] % mod
    # 결석 2회가 될 경우 i-1번째에서 결석 1회였던경우에서 현재 결석
    DP[i][0][2] = DP[i-1][0][1] % mod
    DP[i][1][2] = DP[i-1][1][1] % mod

answer = 0
for i in range(0, 3):
    answer += (DP[N-1][0][i] + DP[N-1][1][i])
answer = answer % mod
print(answer)